#!/bin/bash

set -e -u -o pipefail
shopt -s inherit_errexit
shopt -s expand_aliases

alias cache_git='git -C "${bare_repo}" '
alias local_git='git -C "${local_repo}" '

_main() {
	local bare_repo
	local action

	action=$1
	shift

	readonly bare_repo=~/.cache/bare_reference_repo.git

	case "${action}" in
	warm)
		warm "$@"
		;;
	clone)
		clone "$@"
		;;
	*)
		echo >&2 "Unknown action $action"
		return 1
		;;
	esac
}

clone() {
	local repo_url local_repo

	repo_url=$1
	local_repo=$2

	local remote_name head_ref
	local old_remote_name
	remote_name=$(unique_remote_name "${repo_url}")
	old_remote_name=$(unique_remote_name::old "${repo_url}")

	fetch "${remote_name}" "${repo_url}" "${old_remote_name}"

	git clone --origin fast-clone --no-tags --no-checkout "${bare_repo}" "${local_repo}"
	local_git config --replace-all "remote.fast-clone.fetch" "+refs/remotes/${remote_name}/*:refs/remotes/fast-clone/remotes/*"
	local_git fetch --quiet fast-clone
	local_git remote add origin "${repo_url}"
	local_git fetch origin
	local_git remote rm fast-clone
	local_git remote set-head --auto origin
	head_ref=$(local_git symbolic-ref refs/remotes/origin/HEAD)
	local_git checkout -B "${head_ref#refs/remotes/origin/}" "${head_ref}"
}

warm() {
	local local_repo
	local repo_url
	local remote_name
	local old_remote_name

	local_repo=$1
	repo_url=$2

	init_reference_repo

	remote_name=$(unique_remote_name "${repo_url}")
	old_remote_name=$(unique_remote_name::old "${repo_url}")
	fetch "${remote_name}" "${local_repo}" "${old_remote_name}"
}

fetch() {
	local remote_name
	local repo
	local old_remote_name

	remote_name=$1
	repo=$2
	old_remote_name=$3

	init_reference_repo

	if cache_git remote set-url "${remote_name}" "${repo}"; then
		true
	else
		cache_git remote add --no-tags "${remote_name}" "${repo}"
	fi
	cache_git config --replace-all "remote.${remote_name}.fetch" "+refs/remotes/*:refs/remotes/${remote_name}/remotes/*"
	cache_git config --add "remote.${remote_name}.fetch" "+refs/heads/*:refs/remotes/${remote_name}/heads/*"
	cache_git config --add "remote.${remote_name}.fetch" "+refs/tags/*:refs/remotes/${remote_name}/tags/*"
	cache_git fetch --quiet "${remote_name}"
	if cache_git remote get-url "${old_remote_name}" &>/dev/null; then
		cache_git remote rm "${old_remote_name}"
	fi
}

unique_remote_name() {
	local repo_url
	repo_url=$1

	printf "%s-%s" "$(basename "${repo_url}")" "$(very_unique_csum "${repo_url}")"
}

unique_remote_name::old() {
	local repo_url
	local old_csum
	repo_url=$1

	old_csum="$(printf '%s' "${repo_url}" | md5sum | cut -c 1-8)"
	printf "%s-%s" "$(basename "${repo_url}")" "${old_csum}"
}

init_reference_repo() {
	if [ -d "${bare_repo}" ] && cache_git rev-parse --is-bare-repository; then
		true
	else
		git init --bare "${bare_repo}"
	fi
}

very_unique_csum() {
	local repo_url
	repo_url=$1
	printf '%s' "${repo_url}" | md5sum | cut -c 1-2
}

_main "$@"
